// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../ozcore/ozone.h"
#include "OZTravService.h"
#include <signal.h>
#include <iostream>
#include <protocol/TBinaryProtocol.h>
#include <server/TThreadPoolServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <concurrency/ThreadManager.h>
#include <concurrency/PosixThreadFactory.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::server;
using namespace std;

using boost::shared_ptr;

using namespace ozstore;

class OZTravServiceHandler : virtual public OZTravServiceIf {
	public:
		OZTravServiceHandler(const string path)
		{
			// Open Trav Handle
			if(oztrav_open(&ot, path.c_str()))
			{
				throw TException("Open db fail.");
			}

			// Init mutex
			if(pthread_mutex_init(&_lock, NULL))
			{   
				throw TException("Init mutex fail.");
			}

			// Init Cursor
			oztrav_cursor_init(&cur);
		}

		~OZTravServiceHandler()
		{
			oztrav_cursor_free(&cur);
			oztrav_close(&ot);
			pthread_mutex_destroy(&_lock);
		}

		void next_kv(TravPair& _return, int32_t acur)
		{
			// Lock
			if(pthread_mutex_lock(&_lock))
			{   
				pthread_mutex_unlock(&_lock);
				return ;
			}

			// Set cursor && @Next
			cur._cur = acur;
			int ret = oztrav_next(&ot, &cur);

			// OutputResult
			if(!ret)
			{   
				_return.key.assign(cur._key, cur._key_len);
				_return.value.assign(cur._value, cur._value_len);
				_return.cur = cur._cur;
			}  
			else if (ret==1)
			{
				pthread_mutex_unlock(&_lock);
				throw TException("Have reach the end of record.");
			}

			// Unlock
			pthread_mutex_unlock(&_lock);
		}

	private:
		// OZTrav
		OZTrav ot;
		// OZTrav Cursor
		OZTrav_Cursor cur;
		// Mutex lock
		pthread_mutex_t _lock;

};


TThreadPoolServer* ozserver_tp = NULL;

void handler_shutdown_tp(int num)
{
	if(ozserver_tp)
	{
		ozserver_tp->stop();
		//delete ozserver_tp;
	}
}

void server_threadpool(const string path, int port, int threads)
{	
	//Signal
	signal(SIGTERM, handler_shutdown_tp);
	signal(SIGINT, handler_shutdown_tp);

	//Create TProcessor
	shared_ptr<OZTravServiceHandler> handler(new OZTravServiceHandler(path));
	shared_ptr<TProcessor> processor(new OZTravServiceProcessor(handler));

	//Create ServerTransport
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));

	//Create TransportFactory
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());

	//Create TProtocolFactory
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	//Create ThreadManager
	shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(threads);
	shared_ptr<ThreadFactory> threadFactory(new PosixThreadFactory());
	threadManager->threadFactory(threadFactory);
	threadManager->start();

	//Create ThreadPool Server
	ozserver_tp  = new TThreadPoolServer(processor, serverTransport , transportFactory, protocolFactory, threadManager);
	cout << "OZoneStore Trav Server Starting ..." << endl;
	ozserver_tp->serve();
	delete ozserver_tp;
	cout << "OZoneStore Trav Server Stopping ..." << endl;

}

int main(int argc, char **argv)
{
	//Param
	if(argc!=3)
	{
		cout << "Usage:" << endl;
		cout << argv[0] << " [port] [path]" << endl;
		return -1;
	}

	//Init Param
	int port = atoi(argv[1]);
	string path(argv[2]);
	int numThreads = 8;


	//NonBlocking Server	
	//server_nonblocking(path, port, numThreads);

	//ThraedPool Server
	server_threadpool(path, port, numThreads);

	return 0;
}

// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../ozcore/ozone.h"
#include "OZReadService.h"
#include <transport/TBufferTransports.h>
#include <signal.h>
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <concurrency/ThreadManager.h>
#include <concurrency/PosixThreadFactory.h>
#include <server/TNonblockingServer.h>
#include <string>
#include <iostream>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
using namespace std;

using boost::shared_ptr;

using namespace ozstore;

class OZReadServiceHandler : virtual public OZReadServiceIf {
	public:
		OZReadServiceHandler(const string& path) {
			//Init OZRead Handler
			if(ozread_open(&_or, path.c_str()))
			{
				throw TException("Open db fail.");
			}

		}

		~OZReadServiceHandler()
		{
			ozread_close(&_or);
		}

		void get(std::string& _return, const std::string& key) {
			//Prepare param (key)
			OZRead_Get param = {NULL, NULL};
			param._key = (char*)key.c_str();

			//Get & result
			OZException exp;
			int ret = ozread_get(&_or, &param);

			switch(ret)
			{
				case 0:
					_return.assign(param._value, param._len);
					break;
				case 1:
					exp.why = "invalid handle";
					break;
				case 2:
					exp.why = "invalid param";
					break;
				case 3:
					exp.why = "key not found";
					break;
				case 4:
					exp.why = "get value fail";
					break;
				case 5:
					exp.why = "malloc for value fail";
					break;
				default:
					exp.why = "unknown error";
			}
			ozread_get_free(&param);
			if(ret)
			{
				throw exp;
			}
		}

		void gets(std::vector<std::string> & _return, const std::vector<std::string> & keys) {
			//Param	
			OZRead_Gets gets;
			OZException exp;
			if(ozread_gets_init(&gets, keys.size()))
			{
				exp.why = "malloc for OZRead_Gets fail";
				throw exp;
			}

			//Copy keys
			for(size_t i=0; i<keys.size(); i++)
			{
				gets._keys[i] = (char*)keys[i].c_str();
			}

			//Read Values
			int ret;
			ret = ozread_gets(&_or, &gets);
			
			switch(ret)
			{
				case 0:
					//succ
					for(size_t i=0; i<gets._nkeys; i++)
					{
						string str;
						if(gets._values[i])
						{
							str.assign(gets._values[i]);
						}
						_return.push_back(str);
					}
					break;
				case 1:
					exp.why = "invalid handle";
					break;
				case 2:
					exp.why = "invalid param";
					break;
				case 3:
					exp.why = "malloc for values fail";
					break;
				default:
					break;
			}

			//Free resource & return
			ozread_gets_free(&gets);

			if(ret)
			{
				throw exp;
			}
		}

	private:
		OZRead _or;


};

TNonblockingServer* ozserver = NULL;

void handler_shutdown(int num)
{
	if(ozserver)
	{
		delete ozserver;
	}
}

int main(int argc, char **argv)
{
	//Param
	if(argc!=3)
	{
		cout << "Usage:" << endl;
		cout << argv[0] << " [port] [path]" << endl;
		return -1;
	}

	//Init Param
	int port = atoi(argv[1]);
	string path(argv[2]);
	int numThreads = 8;

	//Bind signal
	signal(SIGTERM, handler_shutdown);
	signal(SIGINT, handler_shutdown);

	//Create TProcessor
	shared_ptr<OZReadServiceHandler> handler(new OZReadServiceHandler(path));
	shared_ptr<TProcessor> processor(new OZReadServiceProcessor(handler));

	//Create TProtocolFactory
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	//Create ThreadManager
	shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(numThreads);
	shared_ptr<ThreadFactory> threadFactory(new PosixThreadFactory());
	threadManager->threadFactory(threadFactory);
	threadManager->start();

	//Create TNonblockingServer
	ozserver = new TNonblockingServer(processor, protocolFactory, port, threadManager);
	cout << "OZoneStore Read Server Starting ..." << endl;
	ozserver->serve();
	cout << "OZoneStore Read Server Stopping ..." << endl;
	return 0;
}

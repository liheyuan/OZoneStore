// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../ozcore/ozone.h"
#include "OZWriteService.h"
#include <signal.h>
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <server/TThreadPoolServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>
#include <concurrency/ThreadManager.h>
#include <concurrency/PosixThreadFactory.h>
#include <server/TNonblockingServer.h>
#include <string>
#include <iostream>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;
using namespace std;

using boost::shared_ptr;

using namespace ozstore;

#define KEY_LEN 16

class OZWriteServiceHandler : virtual public OZWriteServiceIf
{
	public:
		OZWriteServiceHandler(const string& path)
		{
			// Open DB
			if(ozwrite_open(&ow, path.c_str()))
			{
				throw TException("Open db fail.");
			}

			// Init mutex
			if(pthread_mutex_init(&_lock, NULL))
			{   
				throw TException("Init mutex fail.");
			}
			
			// Get max unique id
			getmax(path.c_str());
		}

		virtual ~OZWriteServiceHandler()
		{
			ozwrite_close(&ow);
			pthread_mutex_destroy(&_lock);
		}

		void getmax(const char* dbpath)
		{
			// Init
			_id = 0;
			// Get max id from key.dat
			char fn[OZ_BUF_SIZE];
			snprintf(fn, OZ_BUF_SIZE, "%s/%s", dbpath, OZ_KEY_FILENAME);
			FILE* fp = fopen(fn, "rb");
			if(!fp)
			{
				return ;
			}
			// Get max
			char sid[OZ_KEY_BUF_SIZE];
			long id;
			off_t off;
			uint32_t len;
			while( fscanf(fp, "%s\t%lld\t%u", sid, &off, &len) != EOF )
			{
				id = atoi(sid);
				if(id>_id)
				{
					_id = id;
				}
			}
			_id++;
			//cout << _id << endl;
			fclose(fp);
		}

		void put(const std::string& value)
		{
			//Lock
			if(pthread_mutex_lock(&_lock))
			{
				pthread_mutex_unlock(&_lock);
				return ;
			}

			//Make Incremental Key
			snprintf(_key, KEY_LEN, "%ld", _id++);

			//Try put
			int ret = ozwrite_put(&ow, _key, value.c_str(), value.length());
			if(!ret)
			{
				//Succ, unlock and return
				pthread_mutex_unlock(&_lock);
				return ;
			}
			// Not success
			OZException exp;
			switch(ret)
			{
				case 1:
					exp.why = "invalid handle";
					break;
				case 2:
					exp.why = "write key error";
					break;
				case 3:
					exp.why = "write value error";
					break;
				case 4:
					exp.why = "ftello fail";
				case 5:
					exp.why = "value length can't be zero";
					break;
				case 6:
					exp.why = "key length can't be zero";
					break;
				default:
					exp.why = "unknown error";
					break;
			}

			//Unlock and return
			pthread_mutex_unlock(&_lock);
			throw exp;
		}

		void puts(const std::vector<std::string> & values)
		{
			//Lock
			if(pthread_mutex_lock(&_lock))
			{
				pthread_mutex_unlock(&_lock);
				return ;
			}
			
			//Put each values
			for(size_t i=0; i<values.size(); i++)
			{
				//Make Incremental Key
				snprintf(_key, KEY_LEN, "%ld", _id++);

				//Try put and ignore result
				ozwrite_put(&ow, _key, values[i].c_str(), values[i].length());

			}

			//Unlock
			pthread_mutex_unlock(&_lock);
		}

	private:
		// OZoneWrite handle (shared by all threads, guard by _lock)
		OZWrite ow;

		// Mutex lock
		pthread_mutex_t _lock;

		// Key Buffer (shared by all thread, guared by _lock)
		char _key[KEY_LEN];

		// Key ID incremental (shared by all thread, guared by _lock)
		long _id;

};


TNonblockingServer* ozserver_nb = NULL;

void handler_shutdown_nb(int num)
{
	if(ozserver_nb)
	{
		ozserver_nb->stop();
		delete ozserver_nb;
	}
}

//NonBlockingServer
void server_nonblocking(const string path, int port, int threads)
{
	//Bind signal
	signal(SIGTERM, handler_shutdown_nb);
	signal(SIGINT, handler_shutdown_nb);

	//Create TProcessor
	shared_ptr<OZWriteServiceHandler> handler(new OZWriteServiceHandler(path));
	shared_ptr<TProcessor> processor(new OZWriteServiceProcessor(handler));

	//Create TProtocolFactory
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	//Create ThreadManager
	shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(threads);
	shared_ptr<ThreadFactory> threadFactory(new PosixThreadFactory());
	threadManager->threadFactory(threadFactory);
	threadManager->start();

	//Create TNonblockingServer
	ozserver_nb = new TNonblockingServer(processor, protocolFactory, port, threadManager);
	cout << "OZoneStore Write Server Starting ..." << endl;
	ozserver_nb->serve();
	cout << "OZoneStore Write Server Stopping ..." << endl;

}

TThreadPoolServer* ozserver_tp = NULL;

void handler_shutdown_tp(int num)
{
	if(ozserver_tp)
	{
		ozserver_tp->stop();
		//delete ozserver_tp;
	}
}

void server_threadpool(const string path, int port, int threads)
{	
	//Signal
	signal(SIGTERM, handler_shutdown_tp);
	signal(SIGINT, handler_shutdown_tp);

	//Create TProcessor
	shared_ptr<OZWriteServiceHandler> handler(new OZWriteServiceHandler(path));
	shared_ptr<TProcessor> processor(new OZWriteServiceProcessor(handler));

	//Create ServerTransport
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));

	//Create TransportFactory
	shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());

	//Create TProtocolFactory
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	//Create ThreadManager
	shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(threads);
	shared_ptr<ThreadFactory> threadFactory(new PosixThreadFactory());
	threadManager->threadFactory(threadFactory);
	threadManager->start();

	//Create ThreadPool Server
	ozserver_tp  = new TThreadPoolServer(processor, serverTransport , transportFactory, protocolFactory, threadManager);
	cout << "OZoneStore Write Server Starting ..." << endl;
	ozserver_tp->serve();
	delete ozserver_tp;
	cout << "OZoneStore Write Server Stopping ..." << endl;

}

int main(int argc, char **argv)
{
	//Param
	if(argc!=3)
	{
		cout << "Usage:" << endl;
		cout << argv[0] << " [port] [path]" << endl;
		return -1;
	}

	//Init Param
	int port = atoi(argv[1]);
	string path(argv[2]);
	int numThreads = 8;


	//NonBlocking Server	
	//server_nonblocking(path, port, numThreads);

	//ThraedPool Server
	server_threadpool(path, port, numThreads);

	return 0;
}
